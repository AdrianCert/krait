var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"krait-toolkit","text":"<p>Yet another tool kit</p>"},{"location":"referince/signal.html","title":"API reference","text":"<p>Module implements a reactive property system inspired by modern web frameworks.</p> <p>Module implements a reactive property system inspired by modern web frameworks such as SolidJS and ReactJS. It allows for the creation of properties that can react to changes in their dependencies, enabling automatic recalculation and caching of derived values. This is particularly useful for building dynamic, dependency-aware systems in Python.</p>"},{"location":"referince/signal.html#krait.signal--features","title":"Features:","text":"<ul> <li>Signal Handlers: Manage the behavior and lifecycle of signal-enabled properties.   Handlers ensure that the origin value remains consistent with the property they are managing.</li> <li>Dynamic Signals: Support for dynamic, callable properties with caching and   expiration capabilities.</li> <li>Dependency Tracking: Automatically tracks relationships between properties to   propagate changes efficiently, similar to state management in ReactJS.</li> </ul>"},{"location":"referince/signal.html#krait.signal--modules-and-classes","title":"Modules and Classes:","text":"<ul> <li>BaseSignalHandler: A base class for managing signal behaviors, ensuring that handler   origin values remain consistent with the property.</li> <li>SignaledProperty: A descriptor that enables reactive properties, tracking dependencies,   and handling updates automatically.</li> <li>DynamicSignaledType: A specialized handler for callable properties, supporting caching   and controlled expiration of values.</li> <li>signal: A decorator and subclass of <code>SignaledProperty</code> for defining reactive properties   within classes.</li> </ul>"},{"location":"referince/signal.html#krait.signal--notes","title":"Notes","text":"<ul> <li> <p>Limitations: This module have not yet support for handling mutable objects as signals.     In case that a mutable object is used as a signal, the signal will not be triggered when     the object is modified. This is a known limitation and will be addressed in future updates.</p> <p>As a workaround, you can trigger the signal by setting the signal to itself, like this: <pre><code>class ExampleClass:\n    @signal\n    def signal_instance(self):\n        return [1, 2, 3]\n\ninstance = ExampleClass()\ninstance.signal_instance = instance.signal_instance\n# This will trigger the signal and update the downstream properties.\n# or u can do: instance.signal_instance = signal\n</code></pre></p> </li> </ul> <p>This module is suitable for scenarios requiring state management, derived computations, or reactive programming principles in Python.</p>"},{"location":"referince/signal.html#krait.signal.BaseSignalHandler","title":"<code>BaseSignalHandler</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>class BaseSignalHandler(abc.ABC):\n    @classmethod\n    @abc.abstractmethod\n    def accept(cls, value: typing.Any) -&gt; bool: ...\n\n    @abc.abstractmethod\n    def get(self) -&gt; typing.Any: ...\n\n    @abc.abstractmethod\n    def set(self, value) -&gt; bool: ...\n\n    @abc.abstractmethod\n    def alter(self, **kwargs) -&gt; None: ...\n\n    def __init__(\n        self,\n        /,\n        owner: \"SignaledProperty\",\n        context: typing.Optional[SignalContext] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a BaseSignalHandler instance.\n\n        Parameters\n        ----------\n        owner : SignaledProperty\n            The signaled property witch own this\n        context: typing.Optional[SignalContext]\n            The context in where signal were called\n        \"\"\"\n        self.context = context\n        self.owner: SignaledProperty = owner\n\n    def get_value(self):\n        \"\"\"\n        Retrieve the value from the signal property.\n\n        Returns\n        -------\n        Any\n            The value of the signal property.\n        \"\"\"\n        return self.get()\n\n    def set_value(self, value):\n        \"\"\"\n        Set the value for the given instance and triggers alteration if the value is changed.\n\n        Parameters\n        ----------\n        value : any\n            The new value to set.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        altered = self.set(value)\n        if altered:\n            self.notice_alter()\n\n    def notice_alter(self, **kw):\n        context = kw.pop(\"context\", self.context)\n        self.owner.alter(context=context, **kw)\n</code></pre>"},{"location":"referince/signal.html#krait.signal.BaseSignalHandler.__init__","title":"<code>__init__(owner, context=None, **kwargs)</code>","text":"<p>Initialize a BaseSignalHandler instance.</p>"},{"location":"referince/signal.html#krait.signal.BaseSignalHandler.__init__--parameters","title":"Parameters","text":"<p>owner : SignaledProperty     The signaled property witch own this context: typing.Optional[SignalContext]     The context in where signal were called</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def __init__(\n    self,\n    /,\n    owner: \"SignaledProperty\",\n    context: typing.Optional[SignalContext] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initialize a BaseSignalHandler instance.\n\n    Parameters\n    ----------\n    owner : SignaledProperty\n        The signaled property witch own this\n    context: typing.Optional[SignalContext]\n        The context in where signal were called\n    \"\"\"\n    self.context = context\n    self.owner: SignaledProperty = owner\n</code></pre>"},{"location":"referince/signal.html#krait.signal.BaseSignalHandler.get_value","title":"<code>get_value()</code>","text":"<p>Retrieve the value from the signal property.</p>"},{"location":"referince/signal.html#krait.signal.BaseSignalHandler.get_value--returns","title":"Returns","text":"<p>Any     The value of the signal property.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def get_value(self):\n    \"\"\"\n    Retrieve the value from the signal property.\n\n    Returns\n    -------\n    Any\n        The value of the signal property.\n    \"\"\"\n    return self.get()\n</code></pre>"},{"location":"referince/signal.html#krait.signal.BaseSignalHandler.set_value","title":"<code>set_value(value)</code>","text":"<p>Set the value for the given instance and triggers alteration if the value is changed.</p>"},{"location":"referince/signal.html#krait.signal.BaseSignalHandler.set_value--parameters","title":"Parameters","text":"<p>value : any     The new value to set.</p>"},{"location":"referince/signal.html#krait.signal.BaseSignalHandler.set_value--returns","title":"Returns","text":"<p>None</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def set_value(self, value):\n    \"\"\"\n    Set the value for the given instance and triggers alteration if the value is changed.\n\n    Parameters\n    ----------\n    value : any\n        The new value to set.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    altered = self.set(value)\n    if altered:\n        self.notice_alter()\n</code></pre>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler","title":"<code>PrimitiveSignalHandler</code>","text":"<p>               Bases: <code>BaseSignalHandler</code></p> <p>Base class for signal handlers.</p>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler--attributes","title":"Attributes","text":"<p>original_value : Any     The original value of the signal that the handler manages.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>class PrimitiveSignalHandler(BaseSignalHandler):\n    \"\"\"\n    Base class for signal handlers.\n\n    Attributes\n    ----------\n    original_value : Any\n        The original value of the signal that the handler manages.\n    \"\"\"\n\n    original_value: typing.Any\n\n    def __init__(\n        self,\n        origin,\n        use_hashing: typing.Union[bool, typing.Callable[..., bool]] = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a BaseSignalHandler instance.\n\n        Parameters\n        ----------\n        origin : Any\n            The original value of the signal.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.original_value = origin\n        self.hashing = (\n            use_hashing\n            and (use_hashing if callable(use_hashing) else introspect.hash4any)\n            or None\n        )\n        self.use_hashing = use_hashing and True or False\n        self.original_hash = self.hashing and self.hashing(origin) or None\n\n    @classmethod\n    def accept(cls, value: typing.Any) -&gt; bool:\n        \"\"\"\n        Determine whether this handler can process the given value.\n\n        Parameters\n        ----------\n        value : Any\n            The value to be checked.\n\n        Returns\n        -------\n        bool\n            True if the value is accepted by this handler, False otherwise.\n        \"\"\"\n        return True\n\n    def get(self) -&gt; typing.Any:\n        \"\"\"\n        Retrieve the value managed by this signal handler.\n\n        Parameters\n        ----------\n        instance : Any\n            The instance of the class where the signal is defined.\n        owner : type\n            The owner class where the signal is defined.\n\n        Returns\n        -------\n        Any\n            The value managed by this signal handler.\n        \"\"\"\n        return self.original_value\n\n    def set(self, value) -&gt; bool:\n        \"\"\"\n        Set the value managed by this signal handler.\n\n        If the value is different from the original value, the handler will update the\n        original value and return True. Otherwise, it will return False.\n\n        Parameters\n        ----------\n        instance : Any\n            The instance of the class where the signal is defined.\n        value : Any\n            The new value to set.\n        \"\"\"\n        self.original_value = value\n        if self.hashing:\n            new_hash = self.hashing(value)\n            diff_hash = new_hash != self.original_hash\n            self.original_hash = new_hash\n            return diff_hash\n        return True\n\n    def alter(self, **kwargs): ...\n</code></pre>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.__init__","title":"<code>__init__(origin, use_hashing=True, **kwargs)</code>","text":"<p>Initialize a BaseSignalHandler instance.</p>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.__init__--parameters","title":"Parameters","text":"<p>origin : Any     The original value of the signal.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def __init__(\n    self,\n    origin,\n    use_hashing: typing.Union[bool, typing.Callable[..., bool]] = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initialize a BaseSignalHandler instance.\n\n    Parameters\n    ----------\n    origin : Any\n        The original value of the signal.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.original_value = origin\n    self.hashing = (\n        use_hashing\n        and (use_hashing if callable(use_hashing) else introspect.hash4any)\n        or None\n    )\n    self.use_hashing = use_hashing and True or False\n    self.original_hash = self.hashing and self.hashing(origin) or None\n</code></pre>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.accept","title":"<code>accept(value)</code>  <code>classmethod</code>","text":"<p>Determine whether this handler can process the given value.</p>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.accept--parameters","title":"Parameters","text":"<p>value : Any     The value to be checked.</p>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.accept--returns","title":"Returns","text":"<p>bool     True if the value is accepted by this handler, False otherwise.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>@classmethod\ndef accept(cls, value: typing.Any) -&gt; bool:\n    \"\"\"\n    Determine whether this handler can process the given value.\n\n    Parameters\n    ----------\n    value : Any\n        The value to be checked.\n\n    Returns\n    -------\n    bool\n        True if the value is accepted by this handler, False otherwise.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.get","title":"<code>get()</code>","text":"<p>Retrieve the value managed by this signal handler.</p>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.get--parameters","title":"Parameters","text":"<p>instance : Any     The instance of the class where the signal is defined. owner : type     The owner class where the signal is defined.</p>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.get--returns","title":"Returns","text":"<p>Any     The value managed by this signal handler.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def get(self) -&gt; typing.Any:\n    \"\"\"\n    Retrieve the value managed by this signal handler.\n\n    Parameters\n    ----------\n    instance : Any\n        The instance of the class where the signal is defined.\n    owner : type\n        The owner class where the signal is defined.\n\n    Returns\n    -------\n    Any\n        The value managed by this signal handler.\n    \"\"\"\n    return self.original_value\n</code></pre>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.set","title":"<code>set(value)</code>","text":"<p>Set the value managed by this signal handler.</p> <p>If the value is different from the original value, the handler will update the original value and return True. Otherwise, it will return False.</p>"},{"location":"referince/signal.html#krait.signal.PrimitiveSignalHandler.set--parameters","title":"Parameters","text":"<p>instance : Any     The instance of the class where the signal is defined. value : Any     The new value to set.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def set(self, value) -&gt; bool:\n    \"\"\"\n    Set the value managed by this signal handler.\n\n    If the value is different from the original value, the handler will update the\n    original value and return True. Otherwise, it will return False.\n\n    Parameters\n    ----------\n    instance : Any\n        The instance of the class where the signal is defined.\n    value : Any\n        The new value to set.\n    \"\"\"\n    self.original_value = value\n    if self.hashing:\n        new_hash = self.hashing(value)\n        diff_hash = new_hash != self.original_hash\n        self.original_hash = new_hash\n        return diff_hash\n    return True\n</code></pre>"},{"location":"referince/signal.html#krait.signal.SignaledProperty","title":"<code>SignaledProperty</code>","text":"<p>Signal Property.</p> <p>Descriptor for signal-enabled properties that support dependency tracking and automatic updates.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>class SignaledProperty:\n    \"\"\"\n    Signal Property.\n\n    Descriptor for signal-enabled properties that support dependency tracking and\n    automatic updates.\n\n    \"\"\"\n\n    __slots__ = (\n        \"handler\",\n        \"name\",\n        \"shared\",\n        \"owner\",\n        \"_handler_refs\",\n        \"_upstream_signals\",\n        \"_downstream_signals\",\n        \"_hkw\",\n    )\n\n    handler: typing.Type[BaseSignalHandler]\n    shared: bool\n    name: str\n\n    @classmethod\n    def __peek_handler(cls, target) -&gt; typing.Type[BaseSignalHandler]:\n        \"\"\"\n        Determine the appropriate signal handler for a given target.\n\n        Parameters\n        ----------\n        target : Any\n            The target value to be handled.\n\n        Returns\n        -------\n        typing.Type[BaseSignalHandler]\n            The signal handler that can handle the target.\n\n        Raises\n        ------\n        ValueError\n            If no appropriate signal handler is found.\n        \"\"\"\n        for signaled_type in SIGNAL_HANDLER_TYPES:\n            if signaled_type.accept(target):\n                return typing.cast(typing.Type[BaseSignalHandler], signaled_type)\n        raise ValueError(f\"Unsupported signal type: {type(target)}\")  # pragma: no cover\n\n    def __init__(self, origin=__sentinel__, shared: bool = False, **kwargs) -&gt; None:\n        \"\"\"\n        Initialize a SignaledProperty instance.\n\n        Parameters\n        ----------\n        target : Any\n            The initial value of the property.\n        args : tuple\n            Positional arguments for the signal handler.\n        kwargs : dict\n            Keyword arguments for the signal handler.\n        \"\"\"\n        self._upstream_signals: weakref.WeakSet[\"SignaledProperty\"] = weakref.WeakSet()\n        self._downstream_signals: weakref.WeakSet[\"SignaledProperty\"] = (\n            weakref.WeakSet()\n        )\n        self._handler_refs: weakref.WeakKeyDictionary[typing.Any, BaseSignalHandler] = (\n            weakref.WeakKeyDictionary()\n        )\n        self.shared = shared\n        self._hkw = {\"origin\": origin, \"owner\": self, **kwargs}\n\n    def __call__(self, target) -&gt; \"SignaledProperty\":\n        \"\"\"\n        Call the SignaledProperty instance with a new target value.\n\n        Parameters\n        ----------\n        target : Any\n            The new target value.\n\n        Returns\n        -------\n        SignaledProperty\n            A new instance of the SignaledProperty with the updated target value.\n        \"\"\"\n        self._hkw[\"origin\"] = target\n        return self\n\n    def __hash__(self):\n        return id(self) &gt;&gt; 5\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the SignaledProperty instance.\n\n        Returns\n        -------\n        str\n            String representation of the property.\n        \"\"\"\n        return \"signal:{name} {{ {fields} }}\".format(\n            name=self.name,\n            fields=\", \".join(\n                f\"{k}: {v}\"\n                for k, v in {\n                    \"shared\": self.shared,\n                    \"owner\": introspect.repr4cls(self.owner),\n                    \"handler\": introspect.repr4cls(self.handler),\n                }.items()\n            ),\n        )\n\n    def resolve_signal_handler(self, instance, owner=None):\n        ref = owner if self.shared or not instance else instance\n\n        handler = self._handler_refs.get(ref)\n        if handler:\n            return handler\n        self._handler_refs[ref] = handler = self.handler(\n            context=SignalContext(instance, owner), **self._hkw\n        )\n        return handler\n\n    @contextlib.contextmanager\n    def visit_on_setup(self, instance, owner):\n        self.handler = self.__peek_handler(self._hkw[\"origin\"])\n        with self.visit_on_linking(instance, owner) as handler:\n            yield handler\n        self.visit = self.visit_on_linking\n\n    @contextlib.contextmanager\n    def visit_on_linking(self, instance, owner):\n        picker = SignalLinkPicker()\n        picker(self)\n        with self.visit_on_call(instance, owner) as handler:\n            yield handler\n        picker.pop()\n        # need to find a way to optimize the linking signals\n        # given A, B, C signals A -&gt; B, C -&gt; B\n        # when any link done we disable with line bellow\n        # but next time A/C call B and B does not report\n        # It's need to come up with a solution to reactivate B\n        # self.visit = self.visit_on_call\n\n    visit = visit_on_setup\n\n    @contextlib.contextmanager\n    def visit_on_call(self, instance, owner):\n        \"\"\"\n        Context manager for visiting the signal.\n\n        Parameters\n        ----------\n        instance : Any\n            The instance of the class where the signal is defined.\n        owner : type\n            The owner class where the signal is defined.\n\n        \"\"\"\n        try:\n            yield self.resolve_signal_handler(instance, owner)\n        except Exception as exc:\n            # TODO: obfuscate the traceback to the user in order to avoid confusion\n            exc.with_traceback(None)\n            raise\n\n    def __set_name__(self, owner, name):\n        self.name = name\n        self.owner = owner\n\n    def __get__(self, instance, owner):\n        with self.visit(instance, owner) as handler:\n            return handler.get_value()\n\n    def get(self):\n        return self.__get__(None, SignaledProperty)\n\n    def set(self, value):\n        return self.__set__(SignaledProperty, value)\n\n    def __set__(self, instance, value) -&gt; None:\n        # if issubclass(type(value), SignaledProperty):\n        #     # the behavior for setting a signal to another signal it's to trigger a change\n        #     # in that way, the chain of signals will be updated correctly, this operation\n        #     # might be useful for triggering a change in a signal that is not directly related\n        #     # like the signal it's a mutable object and it's downstream attributes are not signals.\n        #     # One example of this is a list or a dict, where the signal is the container\n        #     return self.alter()\n        with self.visit(instance, type(instance)) as handler:\n            handler.set_value(value)\n\n    def link_signal_used(self, other: \"SignaledProperty\", reflexive: bool = True):\n        self._downstream_signals.add(other)\n        if reflexive:\n            other.link_signal_used_by(self, False)\n\n    def link_signal_used_by(self, other: \"SignaledProperty\", reflexive: bool = True):\n        self._upstream_signals.add(other)\n        if reflexive:\n            other.link_signal_used(self, False)\n\n    def alter(\n        self,\n        context: typing.Optional[SignalContext] = None,\n        src: typing.Optional[\"SignaledProperty\"] = None,\n        **kwargs,\n    ):\n        if src and src.shared:\n            for handler in self._handler_refs.values():\n                handler.alter(\n                    **kwargs,\n                )\n        elif context:\n            handler = self.resolve_signal_handler(*context)\n            handler.alter(**kwargs)\n        else:\n            # check when context will be none\n            pass\n\n        for ref_signal in self._upstream_signals:\n            ref_signal.alter(**kwargs, src=self, context=context)\n</code></pre>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__call__","title":"<code>__call__(target)</code>","text":"<p>Call the SignaledProperty instance with a new target value.</p>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__call__--parameters","title":"Parameters","text":"<p>target : Any     The new target value.</p>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__call__--returns","title":"Returns","text":"<p>SignaledProperty     A new instance of the SignaledProperty with the updated target value.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def __call__(self, target) -&gt; \"SignaledProperty\":\n    \"\"\"\n    Call the SignaledProperty instance with a new target value.\n\n    Parameters\n    ----------\n    target : Any\n        The new target value.\n\n    Returns\n    -------\n    SignaledProperty\n        A new instance of the SignaledProperty with the updated target value.\n    \"\"\"\n    self._hkw[\"origin\"] = target\n    return self\n</code></pre>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__init__","title":"<code>__init__(origin=__sentinel__, shared=False, **kwargs)</code>","text":"<p>Initialize a SignaledProperty instance.</p>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__init__--parameters","title":"Parameters","text":"<p>target : Any     The initial value of the property. args : tuple     Positional arguments for the signal handler. kwargs : dict     Keyword arguments for the signal handler.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def __init__(self, origin=__sentinel__, shared: bool = False, **kwargs) -&gt; None:\n    \"\"\"\n    Initialize a SignaledProperty instance.\n\n    Parameters\n    ----------\n    target : Any\n        The initial value of the property.\n    args : tuple\n        Positional arguments for the signal handler.\n    kwargs : dict\n        Keyword arguments for the signal handler.\n    \"\"\"\n    self._upstream_signals: weakref.WeakSet[\"SignaledProperty\"] = weakref.WeakSet()\n    self._downstream_signals: weakref.WeakSet[\"SignaledProperty\"] = (\n        weakref.WeakSet()\n    )\n    self._handler_refs: weakref.WeakKeyDictionary[typing.Any, BaseSignalHandler] = (\n        weakref.WeakKeyDictionary()\n    )\n    self.shared = shared\n    self._hkw = {\"origin\": origin, \"owner\": self, **kwargs}\n</code></pre>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__peek_handler","title":"<code>__peek_handler(target)</code>  <code>classmethod</code>","text":"<p>Determine the appropriate signal handler for a given target.</p>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__peek_handler--parameters","title":"Parameters","text":"<p>target : Any     The target value to be handled.</p>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__peek_handler--returns","title":"Returns","text":"<p>typing.Type[BaseSignalHandler]     The signal handler that can handle the target.</p>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__peek_handler--raises","title":"Raises","text":"<p>ValueError     If no appropriate signal handler is found.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>@classmethod\ndef __peek_handler(cls, target) -&gt; typing.Type[BaseSignalHandler]:\n    \"\"\"\n    Determine the appropriate signal handler for a given target.\n\n    Parameters\n    ----------\n    target : Any\n        The target value to be handled.\n\n    Returns\n    -------\n    typing.Type[BaseSignalHandler]\n        The signal handler that can handle the target.\n\n    Raises\n    ------\n    ValueError\n        If no appropriate signal handler is found.\n    \"\"\"\n    for signaled_type in SIGNAL_HANDLER_TYPES:\n        if signaled_type.accept(target):\n            return typing.cast(typing.Type[BaseSignalHandler], signaled_type)\n    raise ValueError(f\"Unsupported signal type: {type(target)}\")  # pragma: no cover\n</code></pre>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the SignaledProperty instance.</p>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.__repr__--returns","title":"Returns","text":"<p>str     String representation of the property.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the SignaledProperty instance.\n\n    Returns\n    -------\n    str\n        String representation of the property.\n    \"\"\"\n    return \"signal:{name} {{ {fields} }}\".format(\n        name=self.name,\n        fields=\", \".join(\n            f\"{k}: {v}\"\n            for k, v in {\n                \"shared\": self.shared,\n                \"owner\": introspect.repr4cls(self.owner),\n                \"handler\": introspect.repr4cls(self.handler),\n            }.items()\n        ),\n    )\n</code></pre>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.visit_on_call","title":"<code>visit_on_call(instance, owner)</code>","text":"<p>Context manager for visiting the signal.</p>"},{"location":"referince/signal.html#krait.signal.SignaledProperty.visit_on_call--parameters","title":"Parameters","text":"<p>instance : Any     The instance of the class where the signal is defined. owner : type     The owner class where the signal is defined.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>@contextlib.contextmanager\ndef visit_on_call(self, instance, owner):\n    \"\"\"\n    Context manager for visiting the signal.\n\n    Parameters\n    ----------\n    instance : Any\n        The instance of the class where the signal is defined.\n    owner : type\n        The owner class where the signal is defined.\n\n    \"\"\"\n    try:\n        yield self.resolve_signal_handler(instance, owner)\n    except Exception as exc:\n        # TODO: obfuscate the traceback to the user in order to avoid confusion\n        exc.with_traceback(None)\n        raise\n</code></pre>"},{"location":"referince/signal.html#krait.signal.signal","title":"<code>signal</code>","text":"<p>               Bases: <code>SignaledProperty</code></p> <p>The signal property.</p> <p>The signal class is a decorator and descriptor used to define reactive properties in a class. It allows for automatic recalculation and caching of dependent properties when the base properties change. This is particularly useful for scenarios where properties depend on each other and need to be recalculated when their dependencies change.</p> Source code in <code>packages\\signal\\src\\krait\\signal.py</code> <pre><code>class signal(SignaledProperty):  # noqa: N801\n    \"\"\"\n    The signal property.\n\n    The signal class is a decorator and descriptor used to define reactive properties in a class. It allows\n    for automatic recalculation and caching of dependent properties when the base properties change. This\n    is particularly useful for scenarios where properties depend on each other and need to be recalculated\n    when their dependencies change.\n\n    \"\"\"\n</code></pre>"}]}